#include <modules/input/BuildInput.hpp>
#include <modules/core/BuildManager.hpp>
#include <common/Logging.hpp>

#include <magic_enum/magic_enum.hpp>
#include <GLFW/glfw3.h>

#include <dxfsm/dxfsm.hpp>
#include <glm/matrix.hpp>

using namespace input;
using namespace core;

namespace {
    struct SelectWorldTile {
        TileCoord coords{};
    };
}

BuildInput::BuildInput(application::EventManager& em, const rendering::Camera& cam, const core::TileGrid& tiles)
    : EventCommandable(em)
    , MeceSubFsm("BuildInput")
    , m_event_manager(&em), m_camera(&cam), m_tiles(&tiles) {
    m_logger.set_level(spdlog::level::debug);
    
    InitializeDefaultStates();

    auto& fsm = GetFsm();
    auto place_tile = AddState("PlaceTileMode", std::bind_front(&BuildInput::StatePlaceTile, this));
    auto delete_mode = AddState("DeleteMode", std::bind_front(&BuildInput::StateDelete, this));

    StateId::PlaceTileMode = place_tile.Id();
    StateId::DeleteMode = delete_mode.Id();

    auto& events = GetEventInfo();
    EventId::ExitMode = events.AddId("ExitMode");
    EventId::SelectTileToPlace = events.AddId("SelectTileToPlace");
    EventId::BeginDeleting = events.AddId("BeginDeleting");
    EventId::Action = events.AddId("Action");

    // Exit transitions
    // WorldTileSelected -> Idle
    // PlaceTile --------^
    // Delete ----------^

    fsm.AddTransition(place_tile.Id(), EventId::ExitMode, MeceSubStates::Idle);
    fsm.AddTransition(delete_mode.Id(), EventId::ExitMode, MeceSubStates::Idle);
    fsm.AddTransition(MeceSubStates::Idle, EventId::ExitMode, MeceSubStates::Inactive);

    // EnterDeleteMode - this can be generated by keypresses so we need
    // the event wired up
    fsm.AddTransition(MeceSubStates::Idle, EventId::BeginDeleting, delete_mode.Id());
    fsm.AddTransition(place_tile.Id(), EventId::BeginDeleting, delete_mode.Id());

    // SelectTileToPlace
    fsm.AddTransition(MeceSubStates::Idle, EventId::SelectTileToPlace, place_tile.Id());
    fsm.AddTransition(delete_mode.Id(), EventId::SelectTileToPlace, place_tile.Id());

    m_drag_helper_place = std::make_unique<DragHelper>(fsm, GetStateInfo(), GetEventInfo(), StateId::PlaceTileMode, "PlaceTileDrag");
    m_drag_helper_delete = std::make_unique<DragHelper>(fsm, GetStateInfo(), GetEventInfo(), StateId::DeleteMode, "DeleteDrag");
    AddExitTransitionsToAllStates();
}

auto BuildInput::StateIdle(FSM& fsm, int self) -> State {
    Event event{};

    while (true) {
        co_await fsm.EmitAndReceive(event);

        auto prev = fsm.GetPreviousState();

        if (event == EventId::ExitMode && prev.has_value() && prev->Id() == self) {
            event = MeceSubEvents::ExitingSubFsm;
            continue;
        } else if (event == EventId::Action) {
            const auto& action = event.Get<Action>();
            const auto* press = std::get_if<KeyPress>(&action.data);

            if (press != nullptr) {
                if (press->IsDownKey(GLFW_KEY_ESCAPE)) {
                    event = MeceSubEvents::ExitingSubFsm;
                    continue;
                } else if (press->IsDownKey(GLFW_KEY_R)) {
                    event = EventId::BeginDeleting;
                    continue;
                }
            }
        }

        event.Clear();
    }
}

auto BuildInput::StatePlaceTile(FSM& fsm, int) -> State {
    Event event{};
    TileType selected_tile{};

    while (true) {
        co_await fsm.EmitAndReceive(event);

        if (event == EventId::SelectTileToPlace) {
            selected_tile = event.Get<TileType>();
            m_logger.info("Selected tile: {}", static_cast<int>(selected_tile));
        } else if (event == m_drag_helper_place->GetDragCompletedId()) {
            const auto& drag_data = event.Get<DragData>();
            const auto start_tile = ScreenToTilePos(drag_data.begin.pos);
            const auto end_tile = ScreenToTilePos(drag_data.end.pos);

            if (start_tile.has_value() && end_tile.has_value()) {
                const TileSelection sel{*start_tile, *end_tile};

                m_event_manager->FireSignal<BuildCommand>([sel, type = selected_tile](BuildManager& bm) {
                    if (sel.start == sel.end) {
                        bm.PlaceTile(sel.start, type);
                    } else {
                        for (auto coord : sel.Iterate()) {
                            bm.PlaceTile(coord, type);
                        }
                    }
                });
            }
        } else if (event == EventId::Action) {
            const auto& action = event.Get<Action>();
            const auto* click = std::get_if<MouseClick>(&action.data);
            const auto* press = std::get_if<KeyPress>(&action.data);

            if (click != nullptr) {
                if (click->button == 0 && click->dir == ButtonDir::Down) {
                    event.Store(m_drag_helper_place->GetDragStartedId(), DragStartedData{*click});
                    continue;
                }
            } else if (press != nullptr) {
                if (press->IsDownKey(GLFW_KEY_R)) {
                    event = EventId::BeginDeleting;
                    continue;
                } else if (press->IsDownKey(GLFW_KEY_ESCAPE)) {
                    event = EventId::ExitMode;
                    continue;
                }
            }
        }

        event.Clear();
    }
}

auto BuildInput::StateDelete(FSM& fsm, int) -> State {
    Event event{};
    
    while (true) {
        co_await fsm.EmitAndReceive(event);

        if (event == m_drag_helper_delete->GetDragCompletedId()) {
            const auto& drag_data = event.Get<DragData>();
            const auto start_tile = ScreenToTilePos(drag_data.begin.pos);
            const auto end_tile = ScreenToTilePos(drag_data.end.pos);

            if (start_tile.has_value() && end_tile.has_value()) {
                const TileSelection sel{*start_tile, *end_tile};

                m_event_manager->FireSignal<BuildCommand>([sel](BuildManager& bm) {
                    if (sel.Area() == 1) {
                        bm.DeleteTopmostTile(sel.start, TileLayer::Walls);
                    } else {
                        for (auto coord : sel.Iterate()) {
                            bm.DeleteTopmostTile(coord, TileLayer::Walls);
                        }
                    }
                });
            }
        } else if (event == EventId::Action) {
            const auto& action = event.Get<Action>();
            const auto* click = std::get_if<MouseClick>(&action.data);
            const auto* press = std::get_if<KeyPress>(&action.data);

            if (click != nullptr && click->button == 0 && click->dir == ButtonDir::Down) {
                event.Store(m_drag_helper_delete->GetDragStartedId(), DragStartedData{*click});
                continue;
            } else if (press != nullptr) {
                if (press->IsDownKey(GLFW_KEY_B) || press->IsDownKey(GLFW_KEY_ESCAPE)) {
                    event = EventId::ExitMode;
                    continue;
                }
            }
        }

        event.Clear();
    }
}

void BuildInput::EnterDeleteMode() {
    GetFsm().InsertEvent(EventId::BeginDeleting);
}

void BuildInput::SelectTileToPlace(TileType tile) {
    GetFsm().InsertEvent(EventId::SelectTileToPlace, tile);
}

void BuildInput::ExitMode() {
    GetFsm().InsertEvent(EventId::ExitMode);
}

std::optional<TileCoord> BuildInput::ScreenToTilePos(glm::vec2 screen_pos) const {
    const auto cam_view = m_camera->GetViewMatrix();
    const auto world_pos = glm::inverse(cam_view) * glm::vec4(screen_pos, 1, 1);
    return m_tiles->WorldPosToTileCoord(world_pos);
}

void BuildInput::OnStateChanged(const FSM&, std::optional<State>, State to, const Event&) {
    const auto check = to.Id();
    BuildInputStates res{};
    
    if (check == MeceSubStates::Inactive) {
        res = BuildInputStates::InactiveMode;
    } else if (check == MeceSubStates::Idle) {
        res = BuildInputStates::IdleMode;
    } else if (check == StateId::PlaceTileMode) {
        res = BuildInputStates::PlaceTileMode;
    } else if (check == StateId::DeleteMode) {
        res = BuildInputStates::DeleteMode;
    } else if (check == m_drag_helper_place->GetDragStateId()) {
        res = BuildInputStates::PlaceTileDragMode;
    } else if (check == m_drag_helper_delete->GetDragStateId()) {
        res = BuildInputStates::DeleteDragMode;
    } else {
        assert(false);
    }

    m_event_manager->FireSignal(BuildInputStateChanged{res});
}