#include <services/BuildInput.hpp>
#include <services/Logging.hpp>

#include <magic_enum/magic_enum.hpp>
#include <GLFW/glfw3.h>

#include <dxfsm/dxfsm.hpp>
#include <glm/matrix.hpp>

using namespace services;
using namespace commands;

namespace {
    struct SelectWorldTile {
        TileCoord coords{};
    };
}


BuildInput::BuildInput(EventManager& em, const Camera& cam, const TileGrid& tiles)
    : m_event_manager(&em), m_camera(&cam), m_tiles(&tiles) {
    m_logger.set_level(spdlog::level::debug);
    
    using enum StateId;
    using enum EventId;

    StateIdle(m_fsm, IdleMode);
    StatePlaceTile(m_fsm, PlaceTileMode);
    StateWorldTileSelected(m_fsm, WorldTileSelectedMode);
    StateDelete(m_fsm, DeleteMode);
    
    m_fsm.SetCurrentState(IdleMode);

    // Exit transitions
    // WorldTileSelected -> Idle
    // PlaceTile --------^
    // Delete ----------^

    m_fsm.AddTransition(WorldTileSelectedMode, ExitMode, IdleMode);
    m_fsm.AddTransition(PlaceTileMode, ExitMode, IdleMode);
    m_fsm.AddTransition(DeleteMode, ExitMode, IdleMode);

    // EnterDeleteMode - this can be generated by keypresses so we need
    // the event wired up
    m_fsm.AddTransition(IdleMode, BeginDeleting, DeleteMode);
    m_fsm.AddTransition(PlaceTileMode, BeginDeleting, DeleteMode);

    // SelectTileToPlace
    m_fsm.AddTransition(IdleMode, SelectTileToPlace, PlaceTileMode);
    m_fsm.AddTransition(WorldTileSelectedMode, SelectTileToPlace, PlaceTileMode);
    m_fsm.AddTransition(DeleteMode, SelectTileToPlace, PlaceTileMode);
    
    // SelectWorldTile
    m_fsm.AddTransition(IdleMode, SelectWorldTile, WorldTileSelectedMode);

    em.GetOrRegisterSignal<commands::BuildInputCommand>()
        .signal.connect<&BuildInput::ProcessBuiltInputCommand>(this);

    m_fsm.SetTransitionObserver([this](const FSM_t&, std::optional<State_t> from, State_t to, const Event_t& ev) {
        std::string ev_str = !ev.Empty() ? std::format(" Event: {}", magic_enum::enum_name(ev.GetId())) : "";
        
        if (!from.has_value()) {
            m_logger.info("Transitioning to {}.{}", magic_enum::enum_name(to.Id()), ev_str);
        } else {
            m_logger.info(
                "Transitioning from {} to {}.{}",
                magic_enum::enum_name(from->Id()),
                magic_enum::enum_name(to.Id()),
                ev_str
            );
        }

        m_event_manager->GetSignal<BuildInputStateChanged>()
            .signal.fire(BuildInputStateChanged{to.Id()});
    });
}

auto BuildInput::StateIdle(FSM_t& fsm, StateId) -> State_t {
    Event_t event{};

    while (true) {
        co_await fsm.EmitAndReceive(event);

        if (event == EventId::KeyPress) {
            const auto& press = event.Get<KeyPress>();

            if (press.dir == ButtonDir::Down && press.key == GLFW_KEY_R) {
                event = EventId::BeginDeleting;
                continue;
            } else {
                uncaptured_actions.Send(Action{press});
            }
        }

        event.Clear();
    }
}

auto BuildInput::StatePlaceTile(FSM_t& fsm, StateId) -> State_t {
    Event_t event{};
    TileType selected_tile{};

    TileCoord drag_start{};
    bool drag_valid = false;

    while (true) {
        co_await fsm.EmitAndReceive(event);

        if (event == EventId::SelectTileToPlace) {
            selected_tile = event.Get<TileType>();
            m_logger.info("Selected tile: {}", static_cast<int>(selected_tile));
        } else if (event == EventId::Click) {
            const auto& click = event.Get<MouseClick>();

            if (click.button == 0 && click.dir == ButtonDir::Down) {
                const auto tile_pos = ScreenToTilePos(click.pos);

                if (tile_pos.has_value()) {
                    drag_start = *tile_pos;
                    drag_valid = true;
                } else {
                    drag_valid = false;
                }
            } else if (click.button == 0 && click.dir == ButtonDir::Up) {
                if (drag_valid) {
                    const auto tile_pos = ScreenToTilePos(click.pos);

                    if (tile_pos.has_value()) {
                        auto cmd = commands::MakeCommandPtr<commands::PlaceTiles>();
                        cmd->from = drag_start;
                        cmd->to = *tile_pos;
                        cmd->type = selected_tile;
                        
                        build_commands.Send(std::move(cmd));
                    }
                }

                drag_valid = false;
            } else {
                uncaptured_actions.Send(Action{click});
            }
        } else if (event == EventId::KeyPress) {
            const auto& press = event.Get<KeyPress>();

            if (press.key == GLFW_KEY_R) {
                event = EventId::BeginDeleting;
                continue;
            } else {
                uncaptured_actions.Send(Action{press});
            }
            // rotate?
        }

        event.Clear();
    }
}

auto BuildInput::StateWorldTileSelected(FSM_t& fsm, StateId) -> State_t {
    Event_t event{};
    TileCoord selected_tile{};

    while (true) {
        co_await fsm.EmitAndReceive(event);

        if (event == EventId::SelectWorldTile) {
            const auto& tile = event.Get<SelectWorldTile>();
            selected_tile = tile.coords;

            m_logger.info(
                "Selecting world tile at coords {}, {}",
                tile.coords.x, tile.coords.y
            );
        } else if (event == EventId::Click) {
            const auto& click = event.Get<MouseClick>();

            if (click.button == 0 && click.dir == ButtonDir::Down) {
                m_logger.info(
                    "Selecting world tile at world pos {}, {}",
                    click.pos.x, click.pos.y
                );
            }
        } else if (event == EventId::KeyPress) {
            const auto& press = event.Get<KeyPress>();

            if (press.key == GLFW_KEY_D && press.dir == ButtonDir::Down) {
                m_logger.info(
                    "Deleting tile at coords {}, {}",
                    selected_tile.x, selected_tile.y
                );

                // Go back to build mode after deleting the tile
                event = EventId::ExitMode;
                continue;
            } else {
                uncaptured_actions.Send(Action{press});
            }
            // rotate?
        }

        event.Clear();
    }
}

auto BuildInput::StateDelete(FSM_t& fsm, StateId) -> State_t {
    Event_t event{};
    
    while (true) {
        co_await fsm.EmitAndReceive(event);

        if (event == EventId::Click) {
            const auto& click = event.Get<MouseClick>();
            
            if (click.button == 0 && click.dir == ButtonDir::Up) {
                m_logger.info("Delete tile at {}, {}", click.pos.x, click.pos.y);

                const auto tile_pos = ScreenToTilePos(click.pos);
                if (tile_pos.has_value()) {
                    auto cmd = commands::MakeCommandPtr<commands::DeleteTiles>();
                    cmd->from = *tile_pos;
                    cmd->to = *tile_pos;
                    build_commands.Send(std::move(cmd));
                }
            }
        } else if (event == EventId::KeyPress) {
            const auto& press = event.Get<KeyPress>();

            if (press.key == GLFW_KEY_B) {
                event = EventId::ExitMode;
                continue;
            } else if (press.key == GLFW_KEY_ESCAPE) {
                event = EventId::ExitMode;
                continue;
            } else {
                uncaptured_actions.Send(Action{press});
            }
        }

        event.Clear();
    }
}

void BuildInput::Consume(Action&& action) {
    std::visit([&action, this]<typename T>(const T& a) -> void {
        if constexpr (std::is_same_v<T, MouseClick>) {
            m_fsm.InsertEvent(EventId::Click, a);
        } else if constexpr (std::is_same_v<T, KeyPress>) {
            const KeyPress& press = a;

            if (press.key == GLFW_KEY_ESCAPE && press.dir == ButtonDir::Down) {
                ExitMode();
            } else {
                m_fsm.InsertEvent(EventId::KeyPress, a);
            }
        } else if constexpr (std::is_same_v<T, MouseMove>) {
            uncaptured_actions.Send(std::move(action));
        }
    }, action.data);
}

void BuildInput::EnterDeleteMode() {
    m_fsm.InsertEvent(EventId::BeginDeleting);
}

void BuildInput::SelectTileToPlace(TileType tile) {
    m_fsm.InsertEvent(EventId::SelectTileToPlace, tile);
}

void BuildInput::ExitMode() {
    m_fsm.InsertEvent(EventId::ExitMode);
}

void BuildInput::ProcessBuiltInputCommand(const commands::BuildInputCommand& cmd) {
    cmd.Execute(*this);
}

std::optional<TileCoord> BuildInput::ScreenToTilePos(glm::vec2 screen_pos) const {
    const auto cam_view = m_camera->GetViewMatrix();
    const auto world_pos = glm::inverse(cam_view) * glm::vec4(screen_pos, 1, 1);
    return m_tiles->WorldPosToTileCoord(world_pos);
}
